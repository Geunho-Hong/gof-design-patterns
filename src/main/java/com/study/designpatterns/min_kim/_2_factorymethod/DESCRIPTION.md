## 객체 생성 관련 디자인 패턴: 팩토리 메소드 패턴

### Session 1: 패턴 소개

#### 팩토리 메소드 패턴이란?
- 객체의 생성 책임을 팩토리 클래스로 분리해서 생성 로직을 캡슐화하는 패턴
  - 클라이언트는 팩토리 클래스를 통해 인스턴스를 얻기 때문에 클라이언트와 구체 클래스는 느슨한 결합을 할 수 있다.
  - 즉, 클라이언트는 구체 클래스 객체 생성에 대한 로직 등의 변화에 대비할 수 있다.


- 인스턴스를 생성하는 책임을 구체적인 클래스가 아니라 추상적인 인터페이스의 메소드로 감쌀 수 있다.
  - 왜? 
    - 어떤 배를 만드는데, 기존에 화이트쉽만 만드는 공장에서(ShipFactory) 블랙쉽까지 만들어야한다.
    - 배가 추가될 때 마다 if else 문이 들어가면서 코드가 복잡해지기 때문에 이 모든 것을 구체적인 클래스에 담기에 한계가 있다.
    - 그래서 추상화 되어있는 Factory를 만들고, 실제 인스턴스 생성은 Factory 구현체에서 책임진다.
  - 문제?
    - 구체 팩토리 클래스를 알아야 하는 클라이언트는 구체 클래스가 확장되면 코드를 변경해야 한다. -> Session 3

### Session 2: 패턴 적용하기
- _02_after


### Session 3: 인터페이스 적용하기
- 우리가 집중해야 하는 것은 Product와 Creator를 확장할 때 기존 Product와 기존 Creator가 변경되지 않는다는 점이다.
- 클라이언트 코드가 변경되는 부분은 Dependency Injection을 이용해서 해결할 수 있다.

### Session 4: 복습
- 팩토리 메소드 패턴의 장점과 단점?
  - 장점
    - 개방 폐쇄 원칙을 지킬 수 있다.
    - 클래스가 추가되어도 기존 코드를 변경하지 않아도 되기 때문에 복잡해지지 않는다.
  - 단점
    - 추가적인 기능의 클래스가 만들어질 때 마다 팩토리 클래스도 추가되기 때문에 개수가 많아진다.


- 확장에는 열려있고 변경에는 닫혀있는 객체 지향 원칙 설명
  - 확장에는 열려있다.
    - 새로운 기능을 추가할 수 있다.
  - 변경에는 닫혀있다.
    - 기존 코드를 변경하지 않는 것이다.
  - 즉, 개방 폐쇄 원칙은 다형성을 이용해서 클라이언트에서 사용하려는 객체의 구체적인 클래스를 알고있는 것이 아니라 인터페이스나 추상클래스를 사용함으로써 기존 코드를 변경하지 않고 새로운 기능의 구현 클래스를 추가 하는 것이다.
  - 결국 인터페이스나 추상클래스를 정의하고 실제 사용되는 클래스는 이를 구현해야 한다.


- 자바 8에 추가된 인터페이스의 default 메소드에 대해서 설명
  - 자바 8 이전에는 인터페이스의 추상 메소드는 해당 인터페이스를 구현한 클래스에서만 정의할 수 있었는데, default 메소드가 나온 이후로 인터페이스에서도 메소드를 구현할 수 있게 되었다.
  - 인터페이스에서 default 메소드가 구현되었더라도 구현 클래스에서 해당 메소드를 오버라이딩 할 수 있다.
  - default 메소드가 나온 이후로 인터페이스에서도 추상 클래스의 역할을 할 수 있기 때문에 인터페이스 활용도가 높아졌다.


### Session 5: 자바와 스프링에서 찾아보는 패턴

- ExampleTest.java